@using TelstraPurple.Robot.Models
@using TelstraPurple.Robot.Services
@using System.Text.RegularExpressions

@inject IRobotService robotService

<h3>Toy Robot</h3>

<b>Enter no of wells per side</b>
<br />
<input class="input" type="text" @bind="noSquaresInEachSide" />
<input class="button button2" @onclick="setWellsPerSide" type="button" value="Create" />

<hr />

<b>Enter Commands</b>
<br />
<textarea rows="7" cols="50" @bind="commands">@commands</textarea>
<br />
<input class="button button2" @onclick="processMe" type="button" value="Process" />
<input class="button button2" @onclick="clear" type="button" value="Clear" />
<input class="button button2" @onclick="sample" type="button" value="Try sample" />
<hr />

<table>
    @foreach (var wells in fakeArray)
    {
        <tr>
            @foreach (var well in getWells(noSquaresInEachSide - currentElementIndex))
            {
                <td>

                    @if (presentLocation != null && ((well.X == presentLocation.X) && (well.Y == presentLocation.Y)))
                    {
                        <div class="well present">
                            @well.X, @well.Y
                            <div style="text-align:center;padding-top: 12px;">@presentLocation.Direction.ToString()</div>
                        </div>
                    }
                    else
                    {
                        <div class="well">
                            @well.X, @well.Y                            
                        </div>
                    }
                </td>
            }
        </tr>
        currentElementIndex = incrementIndex(currentElementIndex);
    }
</table>

<b>Notes:</b>

<ul>
    <li>Maroon border indicates the current well position.</li>
</ul>


@code {
    const int DEFAULT_NO_OF_WELLS_PER_SIDE = 6;
    private int currentElementIndex = 0;
    private int noSquaresInEachSide;
    private int noSquares;
    private Location presentLocation;
    private Array fakeArray;
    private List<Cell> plate = new List<Cell>();
    private string commands;

    protected override async Task OnInitializedAsync()
    {
        this.noSquaresInEachSide = DEFAULT_NO_OF_WELLS_PER_SIDE;

        fakeArray = new Cell[5];

        List<Cell> plate = new List<Cell>();

        commands = string.Empty;
    }

    int incrementIndex(int index)
    {
        return index + 1;
    }

    async Task setWellsPerSide()
    {
        if (this.noSquaresInEachSide > 0)
        {
            this.currentElementIndex = 0;
            this.noSquares = noSquaresInEachSide * noSquaresInEachSide;
            this.bind();
            this.commands = string.Empty;
            this.presentLocation = null;
        }
        else
        {
            this.noSquaresInEachSide = DEFAULT_NO_OF_WELLS_PER_SIDE;
        }

        await InvokeAsync(() =>
        {
            base.StateHasChanged();
        });
    }

    void bind()
    {
        this.plate = new List<Cell>();

        for (var i = 0; i < this.noSquaresInEachSide; i++)
        {
            for (var j = 0; j < this.noSquaresInEachSide; j++)
            {
                this.plate.Add(new Cell { X = i, Y = j });
            }
        }

        this.fakeArray = new Cell[this.noSquaresInEachSide];
    }

    async Task sample()
    {
        this.noSquaresInEachSide = 6;
        this.currentElementIndex = 0;
        await this.setWellsPerSide();
        this.commands = @"PLACE 1,2,EAST
MOVE
MOVE
LEFT
MOVE";
        await this.process();
    }

    async Task processMe()
    {
        this.currentElementIndex = 0;
        this.noSquares = noSquaresInEachSide * noSquaresInEachSide;
        this.bind();

        await this.process();
    }

    async Task process()
    {
        this.noSquares = noSquaresInEachSide * noSquaresInEachSide;
        this.bind();

        //if no commands, return
        if (!string.IsNullOrEmpty(this.commands) && Regex.Match(this.commands, @"^\s*$").Success)
        {
            return;
        }

        //process commands
        var commands = this.robotService.ParseCommands(this.commands);

        bool isPlaced = false;

        commands.ToList().ForEach(command =>
        {
            if (command != null)
            {
                switch (command.Name)
                {
                    case CommandType.PLACE:
                        Location location = null;
                        if (presentLocation != null)
                        {
                            location = this.robotService.ParsePlaceArgs(command.Arguments, presentLocation.Direction);
                        }
                        else
                        {
                            location = this.robotService.ParsePlaceArgs(command.Arguments);
                        }

                        if (location != null && this.isInBounds(location.X, location.Y, this.noSquaresInEachSide))
                        {
                            this.presentLocation = location;
                            isPlaced = true;
                        }
                        break;
                    case CommandType.MOVE:
                        if (isPlaced)
                        {
                            var locationAfterMove = this.robotService.ParseMove(this.presentLocation);

                            if (locationAfterMove != null && this.isInBounds(locationAfterMove.X, locationAfterMove.Y, this.noSquaresInEachSide))
                            {
                                this.presentLocation = locationAfterMove;
                            }
                        }
                        break;
                    case CommandType.LEFT:
                        if (isPlaced)
                        {
                            this.presentLocation = this.robotService.ParseDirection(this.presentLocation, Movement.LEFT);
                        }
                        break;
                    case CommandType.RIGHT:
                        if (isPlaced)
                        {
                            this.presentLocation = this.robotService.ParseDirection(this.presentLocation, Movement.RIGHT);
                        }
                        break;
                    default:
                        break;
                }
            }
        });

        await InvokeAsync(() =>
        {
            base.StateHasChanged();
        });
    }

    List<Cell> getWells(int y)
    {
        return this.plate.Where(x => x.Y == (y - 1)).ToList();
    }

    Cell getWell(int x, int y)
    {
        var well = this.plate.Find(z => z.X == x && z.Y == y);

        if (well != null)
            return well;

        return null;
    }

    bool isInBounds(int x, int y, int noOfWellsPerSide)
    {
        return (x >= 0 && x < noOfWellsPerSide) && (y >= 0 && y < noOfWellsPerSide);
    }

    void clear()
    {
        this.commands = string.Empty;
        this.presentLocation = null;
        this.bind();
    }
}
